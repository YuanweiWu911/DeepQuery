<!DOCTYPE html>
<html lang="en">

<head>
    <!--
    LLM Query Interface - Frontend Implementation
    
    Provides interactive web interface for DeepSeek-R1 language model operations.
    Core functionalities:
    - Real-time chat with markdown rendering
    - Multi-model selection (1.5B to 70B parameters)
    - Local/Remote execution mode switching
    - Conversation history management
    - Integrated web search capabilities
    - Terminal-like monitoring interface
    - GPU utilization monitoring
    
    Dependencies:
    - marked.js (Markdown rendering)
    - turndown (HTML to Markdown conversion)
    - WebSocket (Real-time communication)
    -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Query Interface</title>
    <link rel="stylesheet" href="static/styles.css">
    <script src="https://unpkg.com/turndown@7.1.1/dist/turndown.js" onerror="alert('Failed to load turndown.js')"></script>
</head>

<body>
    <h2 class="page-title">DeepSeek-R1 Query Tool</h2>

    <div class="input-container">
        <!-- Load Chat button -->
        <button id="load-chat-button" onclick="loadChat()" onmousedown="this.classList.add('button-clicked')" onmouseup="this.classList.remove('button-clicked')">Load Chat</button>
        <!-- New Chat button -->
        <button id="new-chat-button" onclick="newChat()" onmousedown="this.classList.add('button-clicked')" onmouseup="this.classList.remove('button-clicked')">New Chat</button>
        <!-- local/remote toggle button -->
        <button id="local-remote-toggle" class="off" onclick="toggleLocalRemote()">Local</button>
        <select id="model-select">
            <option value="deepseek-r1:1.5b">deepseek-r1:1.5b</option>
            <option value="deepseek-r1:7b">deepseek-r1:7b</option>
            <option value="deepseek-r1:32b" selected>deepseek-r1:32b</option>
            <option value="deepseek-r1:70b">deepseek-r1:70b</option>
        </select>
    </div>

    <div id="ai-response" placeholder="What can I do for you..." contenteditable="true" style="display: none;"></div>
    <div class="input-container">
        <div class="textarea-container">
            <textarea id="prompt" rows="6" cols="90" placeholder="Please enter your question and press Enter to send..."></textarea>
            <button id="send-button" onclick="sendQuery()" onmousedown="this.classList.add('button-clicked')" onmouseup="this.classList.remove('button-clicked')">Enter</button>
            <!-- Save as Json button -->
            <button id="save-button" onclick="saveMessages()" onmousedown="this.classList.add('button-clicked')" onmouseup="this.classList.remove('button-clicked')">Json</button>
            <!-- Save as Markdown button -->
            <button id="markdown-button" onclick="saveAsMarkdown()" onmousedown="this.classList.add('button-clicked')" onmouseup="this.classList.remove('button-clicked')">Markdown</button>
	    <!-- New ReadFile button -->
            <button id="readfile-button" onclick="readFile()" onmousedown="this.classList.add('button-clicked')" onmouseup="this.classList.remove('button-clicked')">ReadFile</button>
            <!-- Search on/off button -->
            <button id="search-toggle" class="off" onclick="toggleSearch()">Search</button>
            <!-- Reason button -->
            <button id="reason-toggle" class="off" onclick="toggleReason()">Reason</button>
            <button id="speech-button" class="off" onclick="toggleSpeech()">Speech</button>
        </div>
    </div>

    <!-- Thinking icon -->
    <div id="thinking-icon" style="display: none;">
        <img src="static/thinking.gif" alt="Thinking...">
    </div>

    <!-- Terminal button and output window -->
    <button id="terminal-button" onclick="toggleTerminal()">Terminal</button>
    <div id="terminal-output" style="display: none; height: 200px; overflow-y: auto; background: black; color: white; padding: 10px; font-family: monospace;">
    </div>
    <!-- GPUbutton -->
    <button id="gpu-button" onclick="getGPUInfo()" onmousedown="this.classList.add('button-clicked')" onmouseup="this.classList.remove('button-clicked')">GPU</button>
    <!--
    <div id="gpu-info" style="display: none; height: 80px; overflow-y: auto; background: black; color: white; padding: 10px; font-family: monospace; margin-top: 5px;"></div>
    -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js" onerror="alert('Failed to load marked.min.js')"></script>
    <script>
        /**
         * Main WebSocket client initialization
         * @event DOMContentLoaded
         * @listens DOMContentLoaded
         * @description Initializes WebSocket connection and sets up message handlers
         */
	let socket = null;
        let context = "";
        let isRemote = false; 
        let synthesis = window.speechSynthesis;
        let utterance = null; 
        let isTerminalVisible = false;
	let ws = null;
        let isGPUInfoVisible = false;
	let textarea;
        let isSearchOn; 
        let isReasonOn; 
        let isSpeechOn;
        
        const aiResponseDiv = document.getElementById('ai-response');
        // 修改DOMContentLoaded监听器为：
        document.addEventListener('DOMContentLoaded', () => {
            const textarea = document.getElementById('prompt');
            const sendButton = document.getElementById('send-button');
            const saveButton = document.getElementById('save-button'); 
            const thinkingIcon = document.getElementById('thinking-icon'); 
            const terminalOutput = document.getElementById('terminal-output');
            searchToggle = document.getElementById('search-toggle');
            reasonToggle = document.getElementById('reason-toggle'); 
            speechButton = document.getElementById('speech-button');

            // WebSocket初始化逻辑...
            socket = new WebSocket('ws://localhost:8765');
            
            socket.addEventListener('message', (event) => {
                const newLine = document.createElement('p');
                newLine.textContent = event.data;
                terminalOutput.appendChild(newLine);
                
                // 自动滚动到底部
                terminalOutput.scrollTop = terminalOutput.scrollHeight;
            });

            socket.addEventListener('error', (event) => {
                console.error('WebSocket error:', event);
            });

            socket.addEventListener('open', (event) => {
                console.log('WebSocket connection established');
            });

            // Listen for the keydown event of the text box
            textarea.addEventListener('keydown', function (event) {
                if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault();
                    sendQuery();
                }
            });
        });

	function toggleTerminal() {
            const terminalOutput = document.getElementById('terminal-output');
            isTerminalVisible = !isTerminalVisible;
            terminalOutput.style.display = isTerminalVisible ? 'block' : 'none';
            
            // 当终端可见时，自动滚动到底部
            if (isTerminalVisible) {
                terminalOutput.scrollTop = terminalOutput.scrollHeight;
            }
        }

        /**
         * Handles query submission and response processing
         * @async
         * @function sendQuery
         * @throws {TypeError} If input validation fails
         * @throws {Error} On network failures or response parsing errors
         * @example
         * // Typical usage flow:
         * // 1. User enters prompt
         * // 2. System shows thinking indicator
         * // 3. Processes search context (if enabled)
         * // 4. Sends request to backend
         * // 5. Renders formatted response
         */
        async function sendQuery() {
            const aiResponseDiv = document.getElementById('ai-response');
            const textarea = document.getElementById('prompt');
            const thinkingIcon = document.getElementById('thinking-icon');
            const selectedModel = document.getElementById('model-select').value;
            const prompt = textarea.value;

            if (!prompt.trim()) {
                alert("Prompt cannot be empty!");
                return;
            }

            // 显示 ai-response 窗口
            aiResponseDiv.style.display = 'block';

            // Show the thinking icon
            thinkingIcon.style.display = 'block';

            let web_context = "";  // Initialize web_context

            // Set the value of web_context based on the search on/off button state
            if (isSearchOn) {
                try {
                    const searchResponse = await fetch('/web_search', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ prompt: prompt })
                    });
                    const searchData = await searchResponse.json();
                    web_context = searchData.web_context;
                } catch (error) {
                    console.error('Search failed:', error);
                }
            }
        
            try {
                const response = await fetch('/query', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ prompt, context, model: selectedModel, search_toggle: isSearchOn }),  // Ensure passing the value of isSearchOn
                });
        
                const result = await response.json();
                if (result.error) {
                    document.getElementById('ai-response').innerText = result.error;
                } else {
                    const aiResponseDiv = document.getElementById('ai-response');
                    const userQuestion = document.createElement('div');
                    userQuestion.classList.add('user-question');
                    userQuestion.innerHTML = `${marked.parse('User')} ${marked.parse(prompt)}`;
                    aiResponseDiv.appendChild(userQuestion);
        
                    const aiResponseText = result.response;
                    const thinkingStartIndex = aiResponseText.indexOf('<think>');
                    const thinkingEndIndex = aiResponseText.indexOf('</think>');
                    if (thinkingStartIndex !== -1 && thinkingEndIndex !== -1) {
                        // Only output ThinkingText when Reason button is pressed
                        if (isReasonOn) {
                            const aiThinking = document.createElement('div');
                            aiThinking.classList.add('ai-thinking');
                            const thinkingText = aiResponseText.substring(thinkingStartIndex + 7, thinkingEndIndex);
                            convertedText = convertUrlsToLinks(thinkingText);
                            aiThinking.innerHTML = `${marked.parse(selectedModel)} ${marked.parse(convertedText)}`;
                            aiResponseDiv.appendChild(aiThinking);
                        }
                        const aiNormalResponse = document.createElement('div');
                        aiNormalResponse.classList.add('ai-response-normal');
                        const normalResponseText = aiResponseText.substring(thinkingEndIndex + 8);
                        convertedText = convertUrlsToLinks(normalResponseText);
                        aiNormalResponse.innerHTML = `${marked.parse(selectedModel)} ${marked.parse(convertedText)}`;
                        aiResponseDiv.appendChild(aiNormalResponse);

                    } else {
                        const aiNormalResponse = document.createElement('div');
                        aiNormalResponse.classList.add('ai-response-normal');
                        convertedText = convertUrlsToLinks(aiResponseText);
                        aiNormalResponse.innerHTML = `${marked.parse(selectedModel)} ${marked.parse(convertedText)}`;
                        aiResponseDiv.appendChild(aiNormalResponse);
                    }
        
                    context = result.context;
                }
            } catch (error) {
                console.error('Error sending query:', error);
            }

            finally {
            // Hide the thinking icon after the response is received
            thinkingIcon.style.display = 'none';
            }
        }

        // Function to start a new chat
        async function newChat() {
            try {
                const response = await fetch('/new-chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                if (response.ok) {
                    context = "";
                    const aiResponseDiv = document.getElementById('ai-response');
                    aiResponseDiv.innerHTML = '';
                }
            } catch (error) {
                console.error('Error resetting chat:', error);
            }
        }

        // New load chat function
        async function loadChat() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        try {
                            const content = JSON.parse(event.target.result);
                            const response = await fetch('/load-chat', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify(content)
                            });
                            if (response.ok) {
                                const data = await response.json();
                                aiResponseDiv.style.display = 'block';
                                aiResponseDiv.innerHTML = '';
                                data.forEach(message => {
                                    const div = document.createElement('div');
                                    // Convert message object to formatted JSON string
                                    const jsonText = JSON.stringify(message, null, 2);
                                    // Wrap JSON text in <pre> tag
                                    const pre = document.createElement('pre');
                                    pre.textContent = jsonText;
                                    // Set font size, here it's set to 16px, you can adjust as needed
                                    pre.style.fontSize = '16px'; 
                                    // Set white-space to pre-wrap, allowing line breaks
                                    pre.style.whiteSpace = 'pre-wrap'; 
                                    // Set word-wrap to break-word, forcing long words to wrap
                                    pre.style.wordWrap = 'break-word'; 
                                    div.appendChild(pre);
                                    aiResponseDiv.appendChild(div);
                                });
                            }
                        } catch (error) {
                            console.error('Error loading chat:', error);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        // New function to toggle the local/remote button state
        /**
         * Toggles execution mode between local and remote
         * @async
         * @function toggleLocalRemote
         * @emits modeChange Notifies backend of mode change
         * @see APIRouterHandler.toggle_local_remote
         */

        async function toggleLocalRemote() {
            const toggleButton = document.getElementById('local-remote-toggle');
            isRemote = !isRemote; // 切换isRemote的值
            toggleButton.classList.toggle('off');
            toggleButton.textContent = isRemote ? 'Remote' : 'Local';
           
            // 发送请求到后端
            const response = await fetch('/toggle-local-remote', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ "isRemote": isRemote })
            });
           
            const data = await response.json();
            if (data.status === 'success') {
                console.log('Local/Remote mode toggled successfully');
            } else {
                console.error('Failed to toggle local/remote mode');
            }
        }

        // New function to toggle the search on/off button state
        function toggleSearch() {
            isSearchOn = !isSearchOn;
            if (isSearchOn) {
                searchToggle.classList.remove('off');
                searchToggle.classList.add('on');
            } else {
                searchToggle.classList.remove('on');
                searchToggle.classList.add('off');
            }
        }

        // New function to toggle the reason on/off button state
        function toggleReason() {
            isReasonOn = !isReasonOn;
            if (isReasonOn) {
                reasonToggle.classList.remove('off');
                reasonToggle.classList.add('on');
            } else {
                reasonToggle.classList.remove('on');
                reasonToggle.classList.add('off');
            }
        }

        /**
         * URL formatting utility
         * @function convertUrlsToLinks
         * @param {string} text - Input text containing raw URLs
         * @returns {string} Formatted text with Markdown-style links
         * @example
         * // Input: "Visit https://example.com"
         * // Output: "Visit [https://example.com]"
         */
        function convertUrlsToLinks(text) {
            // 匹配网址的正则表达式
            const urlRegex = /(https?:\/\/[^\s]+)/g;
        
            // 将匹配到的网址替换为超链接
            return text.replace(urlRegex, function(url) {
                return `[${url}]`;
            });
	}

        // New function to save all messages as a JSON file
        async function saveMessages() {
            try {
                const response = await fetch('/get-all-messages', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                const allMessages = await response.json();
                const jsonData = JSON.stringify(allMessages, null, 2);
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'all_messages.json';
                a.click();
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Error saving messages:', error);
            }
        }
        // New function to save ai_response content as Markdown
        async function saveAsMarkdown() {
            const aiResponseDiv = document.getElementById('ai-response');
            const aiResponseText = aiResponseDiv.innerHTML;

            // Create TurndownService instance                                         
            const turndownService = new TurndownService();
            // Convert HTML to Markdown
            const markdownText = turndownService.turndown(aiResponseText);
        
            // Create a Blob object to save content as a Markdown file
            const blob = new Blob([markdownText], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
    
            // Create an <a> element to trigger the download
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ai_response.md';
            a.click();
    
            // Revoke the URL object
            URL.revokeObjectURL(url);

            try {
                // 发送请求到服务器端记录日志
                const response = await fetch('/save-markdown', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({})
                });

                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
            } catch (error) {
                console.error('Error sending request:', error);
            }
        }

        // 添加语音切换函数
        function toggleSpeech() {
            isSpeechOn = !isSpeechOn;
            if (isSpeechOn) {
                speechButton.classList.remove('off');
                speechButton.classList.add('on');
                speakCurrentResponse();
            } else {
                speechButton.classList.remove('on');
                speechButton.classList.add('off');
                stopSpeech();
            }
        }
        
        // 提取AI响应文本并播放
        function speakCurrentResponse() {
            const aiResponses = document.querySelectorAll('.ai-response-normal');
            if (!aiResponses.length) return;
        
            // 获取最后一个AI响应并去除HTML标签
            const lastResponse = aiResponses[aiResponses.length - 1];
            const text = new DOMParser().parseFromString(lastResponse.innerHTML, "text/html").body.textContent;
        
            if (synthesis.speaking) synthesis.cancel();
        
            utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'zh-CN'; // 中文语音
            utterance.onend = () => {
                speechButton.classList.remove('on');
                speechButton.classList.add('off');
                isSpeechOn = false;
            };
            synthesis.speak(utterance);
        }
        
        // 停止语音
        function stopSpeech() {
            if (synthesis.speaking) {
                synthesis.cancel();
            }
        }

        async function getGPUInfo() {
            try {
                const response = await fetch('/get-gpu-info');
                const data = await response.json();
                const terminalOutput = document.getElementById('terminal-output');
                
                const timestamp = new Date().toLocaleTimeString();
                const gpuHeader = document.createElement('p');
                gpuHeader.innerHTML = `<span style="color: #00ff00;">${timestamp} [GPU监控]</span>`;
                terminalOutput.appendChild(gpuHeader);
        
                if (data.status === 'success') {
                    const infoLines = data.data.split('\n');
                    infoLines.forEach(line => {
                        const p = document.createElement('p');
			p.style.color = '#00ff00';
                        p.style.margin = '2px 0';
                        p.textContent = line;
                        terminalOutput.appendChild(p);
                    });
                } else {
                    const errorLine = document.createElement('p');
                    errorLine.style.color = '#ff0000';
                    errorLine.textContent = `错误: ${data.message}`;
                    terminalOutput.appendChild(errorLine);
                }
                
                terminalOutput.scrollTop = terminalOutput.scrollHeight;
            } catch (error) {
                console.error('获取GPU信息失败:', error);
            }
        }

        // New function to read file and update prompt
        async function readFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.txt, .json, .py, .md'; // 仅允许选择文本文件
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        const fileText = event.target.result;
                        const promptElement = document.getElementById('prompt');
                        // 将文件内容添加到prompt中
			promptElement.value = `用户上传的文件名为 ${file.name}\n.请先阅读以下文件内容：\n${fileText}\n\n然后回答我的问题：`;
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }        
    </script>
</body>

</html>

